# -*- coding: utf-8 -*-
"""MIN Projet Python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1svyjm2S18YbS4c2FDweymKG-bUECASIV
"""

!pip install streamlit pandas numpy matplotlib seaborn plotly pyngrok

from google.colab import files
uploaded = files.upload()  # This opens a file picker to upload customers-100.csv

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import numpy as np
# import plotly.express as px
# from pathlib import Path
# 
# # Set page config
# st.set_page_config(page_title="Customer Manager & Analyzer", layout="wide")
# 
# # Load and clean data
# @st.cache_data
# def load_and_clean_data(/content/customers-100.csv):
#     df = pd.read_csv(file_path)
#     # Remove duplicates
#     df = df.drop_duplicates()
#     # Drop rows with missing critical values
#     df = df.dropna(subset=['First Name', 'Email'])
#     # Drop unnecessary columns
#     df = df.drop(columns=['Index', 'Subscription Date'], errors='ignore')
#     return df
# 
# # File path
# file_path = "customers-100.csv"
# try:
#     df = load_and_clean_data(file_path)
# except FileNotFoundError:
#     st.error("customers-100.csv not found! Please upload the file.")
#     st.stop()
# 
# # Sidebar for navigation
# st.sidebar.title("Navigation")
# view = st.sidebar.radio("Select View", ["Overview", "Table", "Stats"])
# 
# # Overview View
# if view == "Overview":
#     st.title("Customer Data Overview")
#     st.write("Summary statistics of the cleaned customer dataset.")
# 
#     # Summary stats
#     total_customers = len(df)
#     unique_countries = df['Country'].nunique()
#     most_common_country = df['Country'].mode()[0]
#     top_3_cities = df['City'].value_counts().head(3).index.tolist()
#     top_5_companies = df['Company'].value_counts().head(5).index.tolist()
# 
#     col1, col2 = st.columns(2)
#     with col1:
#         st.metric("Total Customers", total_customers)
#         st.metric("Unique Countries", unique_countries)
#     with col2:
#         st.metric("Most Common Country", most_common_country)
#         st.write("Top 3 Cities:", ", ".join(top_3_cities))
#         st.write("Top 5 Companies:", ", ".join(top_5_companies))
# 
# # Table View
# elif view == "Table":
#     st.title("Editable Customer Table")
#     st.write("Edit the dataset below and download the updated version.")
# 
#     # Editable table
#     edited_df = st.data_editor(df, num_rows="dynamic")
# 
#     # Export button
#     if st.button("Export Edited Data"):
#         edited_df.to_csv("edited_customers.csv", index=False)
#         st.download_button(
#             label="Download Edited CSV",
#             data=Path("edited_customers.csv").read_bytes(),
#             file_name="edited_customers.csv",
#             mime="text/csv"
#         )
# 
# # Stats View
# elif view == "Stats":
#     st.title("Customer Data Visualizations")
#     st.write("Graphical insights into customer distribution.")
# 
#     # Bar chart: Top 5 countries
#     top_5_countries = df['Country'].value_counts().head(5)
#     fig1 = px.bar(
#         x=top_5_countries.index,
#         y=top_5_countries.values,
#         labels={'x': 'Country', 'y': 'Customer Count'},
#         title="Top 5 Countries by Customer Count"
#     )
#     st.plotly_chart(fig1)
# 
#     # Bar chart: Top 5 cities
#     top_5_cities = df['City'].value_counts().head(5)
#     fig2 = px.bar(
#         x=top_5_cities.index,
#         y=top_5_cities.values,
#         labels={'x': 'City', 'y': 'Customer Count'},
#         title="Top 5 Cities by Customer Count"
#     )
#     st.plotly_chart(fig2)
# 
#     # Pie chart: Country distribution (Top 5 + Others)
#     country_counts = df['Country'].value_counts()
#     top_n = 5
#     top_countries = country_counts.head(top_n)
#     others_count = country_counts.iloc[top_n:].sum()
#     pie_data = pd.concat([
#         top_countries,
#         pd.Series([others_count], index=['Others'])
#     ])
#     fig3 = px.pie(
#         names=pie_data.index,
#         values=pie_data.values,
#         title=f"Customer Distribution by Country (Top {top_n} + Others)"
#     )
#     st.plotly_chart(fig3)
# 
#     # Pie chart: Email domains
#     df['Email Domain'] = df['Email'].apply(lambda x: x.split('@')[1] if pd.notna(x) else 'Unknown')
#     email_domain_counts = df['Email Domain'].value_counts().head(5)
#     fig4 = px.pie(
#         names=email_domain_counts.index,
#         values=email_domain_counts.values,
#         title="Customer Distribution by Email Domain"
#     )
#     st.plotly_chart(fig4)
# 
#     # Horizontal bar: Top 10 companies
#     top_10_companies = df['Company'].value_counts().head(10)
#     fig5 = px.bar(
#         y=top_10_companies.index,
#         x=top_10_companies.values,
#         orientation='h',
#         labels={'x': 'Customer Count', 'y': 'Company'},
#         title="Top 10 Companies by Customer Count"
#     )
#     st.plotly_chart(fig5)
#

from pyngrok import ngrok
import subprocess

# Set your ngrok authtoken
!2zarR0Ln43mhGvAsMJ0EhKy9P1c_6jj4ELrgSiLKCKtrfB6CK  # Replace with your actual authtoken

# Start Streamlit server
process = subprocess.Popen(['streamlit', 'run', 'app.py', '--server.port', '8501'])

# Create a public URL with ngrok
public_url = ngrok.connect(8501)
print(f"Streamlit app is running at: {public_url}")

# Commented out IPython magic to ensure Python compatibility.
# # Install required libraries
# !pip install streamlit pandas numpy matplotlib seaborn plotly pyngrok
# 
# # Set ngrok authtoken
# !ngrok authtoken 2zarR0Ln43mhGvAsMJ0EhKy9P1c_6jj4ELrgSiLKCKtrfB6CK
# 
# # Write the Streamlit app code (app.py)
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import numpy as np
# import plotly.express as px
# from pathlib import Path
# 
# # Set page config
# st.set_page_config(page_title="Customer Manager & Analyzer", layout="wide")
# 
# # Load and clean data
# @st.cache_data
# def load_and_clean_data(file_path):
#     df = pd.read_csv(file_path)
#     df = df.drop_duplicates()
#     df = df.dropna(subset=['First Name', 'Email'])
#     df = df.drop(columns=['Index', 'Subscription Date'], errors='ignore')
#     return df
# 
# # File path
# file_path = "/content/customers-100.csv"
# try:
#     df = load_and_clean_data(file_path)
# except FileNotFoundError:
#     st.error("customers-100.csv not found! Please upload the file.")
#     st.stop()
# 
# # Sidebar for navigation
# st.sidebar.title("Navigation")
# view = st.sidebar.radio("Select View", ["Overview", "Table", "Stats"])
# 
# # Overview View
# if view == "Overview":
#     st.title("Customer Data Overview")
#     st.write("Summary statistics of the cleaned customer dataset.")
#     total_customers = len(df)
#     unique_countries = df['Country'].nunique()
#     most_common_country = df['Country'].mode()[0]
#     top_3_cities = df['City'].value_counts().head(3).index.tolist()
#     top_5_companies = df['Company'].value_counts().head(5).index.tolist()
#     col1, col2 = st.columns(2)
#     with col1:
#         st.metric("Total Customers", total_customers)
#         st.metric("Unique Countries", unique_countries)
#     with col2:
#         st.metric("Most Common Country", most_common_country)
#         st.write("Top 3 Cities:", ", ".join(top_3_cities))
#         st.write("Top 5 Companies:", ", ".join(top_5_companies))
# 
# # Table View
# elif view == "Table":
#     st.title("Editable Customer Table")
#     st.write("Edit the dataset below and download the updated version.")
#     edited_df = st.data_editor(df, num_rows="dynamic")
#     if st.button("Export Edited Data"):
#         edited_df.to_csv("edited_customers.csv", index=False)
#         st.download_button(
#             label="Download Edited CSV",
#             data=Path("edited_customers.csv").read_bytes(),
#             file_name="edited_customers.csv",
#             mime="text/csv"
#         )
# 
# # Stats View
# elif view == "Stats":
#     st.title("Customer Data Visualizations")
#     st.write("Graphical insights into customer distribution.")
#     top_5_countries = df['Country'].value_counts().head(5)
#     fig1 = px.bar(x=top_5_countries.index, y=top_5_countries.values,
#                   labels={'x': 'Country', 'y': 'Customer Count'}, title="Top 5 Countries by Customer Count")
#     st.plotly_chart(fig1)
#     top_5_cities = df['City'].value_counts().head(5)
#     fig2 = px.bar(x=top_5_cities.index, y=top_5_cities.values,
#                   labels={'x': 'City', 'y': 'Customer Count'}, title="Top 5 Cities by Customer Count")
#     st.plotly_chart(fig2)
#     country_counts = df['Country'].value_counts()
#     top_n = 5
#     top_countries = country_counts.head(top_n)
#     others_count = country_counts.iloc[top_n:].sum()
#     pie_data = pd.concat([top_countries, pd.Series([others_count], index=['Others'])])
#     fig3 = px.pie(names=pie_data.index, values=pie_data.values,
#                   title=f"Customer Distribution by Country (Top {top_n} + Others)")
#     st.plotly_chart(fig3)
#     df['Email Domain'] = df['Email'].apply(lambda x: x.split('@')[1] if pd.notna(x) else 'Unknown')
#     email_domain_counts = df['Email Domain'].value_counts().head(5)
#     fig4 = px.pie(names=email_domain_counts.index, values=email_domain_counts.values,
#                   title="Customer Distribution by Email Domain")
#     st.plotly_chart(fig4)
#     top_10_companies = df['Company'].value_counts().head(10)
#     fig5 = px.bar(y=top_10_companies.index, x=top_10_companies.values, orientation='h',
#                   labels={'x': 'Customer Count', 'y': 'Company'}, title="Top 10 Companies by Customer Count")
#     st.plotly_chart(fig5)
# 
# # Start Streamlit server and ngrok
# from pyngrok import ngrok
# import subprocess
# 
# # Start Streamlit server
# process = subprocess.Popen(['streamlit', 'run', 'app.py', '--server.port', '8501'])
# 
# # Create a public URL with ngrok
# public_url = ngrok.connect(8501)
# print(f"Streamlit app is running at: {public_url}")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import numpy as np
# import plotly.express as px
# from pathlib import Path
# 
# # Set page config
# st.set_page_config(page_title="Customer Manager & Analyzer", layout="wide")
# 
# # Load and clean data
# @st.cache_data
# def load_and_clean_data(file_path):
#     df = pd.read_csv(file_path)
#     df = df.drop_duplicates()
#     df = df.dropna(subset=['First Name', 'Email'])
#     df = df.drop(columns=['Index', 'Subscription Date'], errors='ignore')
#     return df
# 
# # File path
# file_path = "customers-100.csv"
# try:
#     df = load_and_clean_data(file_path)
# except FileNotFoundError:
#     st.error("customers-100.csv not found! Please upload the file.")
#     st.stop()
# 
# # Sidebar for navigation
# st.sidebar.title("Navigation")
# view = st.sidebar.radio("Select View", ["Overview", "Table", "Stats"])
# 
# # Overview View
# if view == "Overview":
#     st.title("Customer Data Overview")
#     st.write("Summary statistics of the cleaned customer dataset.")
#     total_customers = len(df)
#     unique_countries = df['Country'].nunique()
#     most_common_country = df['Country'].mode()[0]
#     top_3_cities = df['City'].value_counts().head(3).index.tolist()
#     top_5_companies = df['Company'].value_counts().head(5).index.tolist()
#     col1, col2 = st.columns(2)
#     with col1:
#         st.metric("Total Customers", total_customers)
#         st.metric("Unique Countries", unique_countries)
#     with col2:
#         st.metric("Most Common Country", most_common_country)
#         st.write("Top 3 Cities:", ", ".join(top_3_cities))
#         st.write("Top 5 Companies:", ", ".join(top_5_companies))
# 
# # Table View
# elif view == "Table":
#     st.title("Editable Customer Table")
#     st.write("Edit the dataset below and download the updated version.")
#     edited_df = st.data_editor(df, num_rows="dynamic")
#     if st.button("Export Edited Data"):
#         edited_df.to_csv("edited_customers.csv", index=False)
#         st.download_button(
#             label="Download Edited CSV",
#             data=Path("edited_customers.csv").read_bytes(),
#             file_name="edited_customers.csv",
#             mime="text/csv"
#         )
# 
# # Stats View
# elif view == "Stats":
#     st.title("Customer Data Visualizations")
#     st.write("Graphical insights into customer distribution.")
# 
#     # Bar chart: Top 5 countries
#     top_5_countries = df['Country'].value_counts().head(5)
#     fig1 = px.bar(x=top_5_countries.index, y=top_5_countries.values,
#                   labels={'x': 'Country', 'y': 'Customer Count'}, title="Top 5 Countries by Customer Count")
#     st.plotly_chart(fig1)
# 
#     # Bar chart: Top 5 cities
#     top_5_cities = df['City'].value_counts().head(5)
#     fig2 = px.bar(x=top_5_cities.index, y=top_5_cities.values,
#                   labels={'x': 'City', 'y': 'Customer Count'}, title="Top 5 Cities by Customer Count")
#     st.plotly_chart(fig2)
# 
#     # Pie chart: Country distribution (Top 5 + Others)
#     country_counts = df['Country'].value_counts()
#     top_n = 5
#     top_countries = country_counts.head(top_n)
#     others_count = country_counts.iloc[top_n:].sum()
#     pie_data = pd.concat([top_countries, pd.Series([others_count], index=['Others'])])
#     fig3 = px.pie(names=pie_data.index, values=pie_data.values,
#                   title=f"Customer Distribution by Country (Top {top_n} + Others)")
#     st.plotly_chart(fig3)
# 
#     # Pie chart: Email domains
#     df['Email Domain'] = df['Email'].apply(lambda x: x.split('@')[1] if pd.notna(x) else 'Unknown')
#     email_domain_counts = df['Email Domain'].value_counts().head(5)
#     fig4 = px.pie(names=email_domain_counts.index, values=email_domain_counts.values,
#                   title="Customer Distribution by Email Domain")
#     st.plotly_chart(fig4)
# 
#     # Horizontal bar: Top 10 companies
#     top_10_companies = df['Company'].value_counts().head(10)
#     fig5 = px.bar(y=top_10_companies.index, x=top_10_companies.values, orientation='h',
#                   labels={'x': 'Customer Count', 'y': 'Company'}, title="Top 10 Companies by Customer Count")
#     st.plotly_chart(fig5)
# 
#     # Optional: Stacked bar chart (Country + Email Availability)
#     email_availability = df.copy()
#     email_availability['Email Status'] = email_availability['Email'].isna().map({True: 'Missing Email', False: 'Has Email'})
#     stacked_data = email_availability.groupby(['Country', 'Email Status']).size().unstack(fill_value=0)
#     fig6 = px.bar(stacked_data, barmode='stack',
#                   title="Customers by Country and Email Availability",
#                   labels={'value': 'Customer Count', 'Country': 'Country'})
#     st.plotly_chart(fig6)
# 
#     # Optional: Box plot (Company Name Length)
#     df['Company Name Length'] = df['Company'].str.len()
#     fig7 = px.box(df, y='Company Name Length',
#                   title="Distribution of Company Name Lengths")
#     st.plotly_chart(fig7)

from pyngrok import ngrok
import subprocess

# Start Streamlit server in the background
process = subprocess.Popen(['streamlit', 'run', 'app.py', '--server.port', '8501'])

# Create a public URL with ngrok
public_url = ngrok.connect(8501)
print(f"Streamlit app is running at: {public_url}")

!cat app.py

import pandas as pd
df = pd.read_csv('customers-100.csv')
print("Dataset Info:")
print(df.info())
print("\nMissing Emails:", df['Email'].isna().sum())
print("\nCompany Column Sample:", df['Company'].head())

!rm -rf ~/.streamlit/cache

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
from pathlib import Path

# Set page config
st.set_page_config(page_title="Customer Manager & Analyzer", layout="wide")

# Load and clean data
@st.cache_data
def load_and_clean_data(file_path):
    try:
        df = pd.read_csv(file_path)
        df = df.drop_duplicates()
        df = df.dropna(subset=['First Name', 'Email'])
        df = df.drop(columns=['Index', 'Subscription Date'], errors='ignore')
        st.write("Data loaded and cleaned successfully.")
        return df
    except Exception as e:
        st.error(f"Error loading data: {e}")
        return None

# File path
file_path = "customers-100.csv"
df = load_and_clean_data(file_path)
if df is None:
    st.stop()

# Sidebar for navigation
st.sidebar.title("Navigation")
view = st.sidebar.radio("Select View", ["Overview", "Table", "Stats"])

# Clear cache button
if st.sidebar.button("Clear Cache"):
    st.cache_data.clear()
    st.write("Cache cleared. Please refresh the page.")

# Overview View
if view == "Overview":
    st.title("Customer Data Overview")
    st.write("Summary statistics of the cleaned customer dataset.")
    total_customers = len(df)
    unique_countries = df['Country'].nunique()
    most_common_country = df['Country'].mode()[0]
    top_3_cities = df['City'].value_counts().head(3).index.tolist()
    top_5_companies = df['Company'].value_counts().head(5).index.tolist()
    col1, col2 = st.columns(2)
    with col1:
        st.metric("Total Customers", total_customers)
        st.metric("Unique Countries", unique_countries)
    with col2:
        st.metric("Most Common Country", most_common_country)
        st.write("Top 3 Cities:", ", ".join(top_3_cities))
        st.write("Top 5 Companies:", ", ".join(top_5_companies))

# Table View
elif view == "Table":
    st.title("Editable Customer Table")
    st.write("Edit the dataset below and download the updated version.")
    edited_df = st.data_editor(df, num_rows="dynamic")
    if st.button("Export Edited Data"):
        edited_df.to_csv("edited_customers.csv", index=False)
        st.download_button(
            label="Download Edited CSV",
            data=Path("edited_customers.csv").read_bytes(),
            file_name="edited_customers.csv",
            mime="text/csv"
        )

# Stats View
elif view == "Stats":
    st.title("Customer Data Visualizations")
    st.write("Graphical insights into customer distribution.")

    try:
        # Bar chart: Top 5 countries
        st.write("Rendering: Top 5 Countries Bar Chart")
        top_5_countries = df['Country'].value_counts().head(5)
        fig1 = px.bar(x=top_5_countries.index, y=top_5_countries.values,
                      labels={'x': 'Country', 'y': 'Customer Count'}, title="Top 5 Countries by Customer Count")
        st.plotly_chart(fig1)

        # Bar chart: Top 5 cities
        st.write("Rendering: Top 5 Cities Bar Chart")
        top_5_cities = df['City'].value_counts().head(5)
        fig2 = px.bar(x=top_5_cities.index, y=top_5_cities.values,
                      labels={'x': 'City', 'y': 'Customer Count'}, title="Top 5 Cities by Customer Count")
        st.plotly_chart(fig2)

        # Pie chart: Country distribution (Top 5 + Others)
        st.write("Rendering: Country Distribution Pie Chart")
        country_counts = df['Country'].value_counts()
        top_n = 5
        top_countries = country_counts.head(top_n)
        others_count = country_counts.iloc[top_n:].sum()
        pie_data = pd.concat([top_countries, pd.Series([others_count], index=['Others'])])
        fig3 = px.pie(names=pie_data.index, values=pie_data.values,
                      title=f"Customer Distribution by Country (Top {top_n} + Others)")
        st.plotly_chart(fig3)

        # Pie chart: Email domains
        st.write("Rendering: Email Domains Pie Chart")
        df['Email Domain'] = df['Email'].apply(lambda x: x.split('@')[1] if pd.notna(x) else 'Unknown')
        email_domain_counts = df['Email Domain'].value_counts().head(5)
        fig4 = px.pie(names=email_domain_counts.index, values=email_domain_counts.values,
                      title="Customer Distribution by Email Domain")
        st.plotly_chart(fig4)

        # Horizontal bar: Top 10 companies
        st.write("Rendering: Top 10 Companies Horizontal Bar Chart")
        top_10_companies = df['Company'].value_counts().head(10)
        fig5 = px.bar(y=top_10_companies.index, x=top_10_companies.values, orientation='h',
                      labels={'x': 'Customer Count', 'y': 'Company'}, title="Top 10 Companies by Customer Count")
        st.plotly_chart(fig5)

        # Optional: Stacked bar chart (Country + Email Availability)
        st.write("Rendering: Stacked Bar Chart (Country + Email Availability)")
        email_availability = df.copy()
        email_availability['Email Status'] = email_availability['Email'].isna().map({True: 'Missing Email', False: 'Has Email'})
        stacked_data = email_availability.groupby(['Country', 'Email Status']).size().unstack(fill_value=0)
        if stacked_data.empty:
            st.warning("No data available for Stacked Bar Chart. Check 'Email' column.")
        else:
            fig6 = px.bar(stacked_data, barmode='stack',
                          title="Customers by Country and Email Availability",
                          labels={'value': 'Customer Count', 'Country': 'Country'})
            st.plotly_chart(fig6)

        # Optional: Box plot (Company Name Length)
        st.write("Rendering: Box Plot (Company Name Length)")
        df['Company Name Length'] = df['Company'].str.len()
        if df['Company Name Length'].isna().all():
            st.warning("No valid company name lengths for Box Plot. Check 'Company' column.")
        else:
            fig7 = px.box(df, y='Company Name Length',
                          title="Distribution of Company Name Lengths")
            st.plotly_chart(fig7)

    except Exception as e:
        st.error(f"Error rendering visualizations: {e}")

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
from pathlib import Path

# Set page config
st.set_page_config(page_title="Customer Manager & Analyzer", layout="wide")

# Load and clean data
@st.cache_data
def load_and_clean_data(file_path):
    try:
        df = pd.read_csv(file_path)
        df = df.drop_duplicates()
        df = df.dropna(subset=['First Name', 'Email'])
        df = df.drop(columns=['Index', 'Subscription Date'], errors='ignore')
        st.write("Data loaded and cleaned successfully.")
        return df
    except Exception as e:
        st.error(f"Error loading data: {e}")
        return None

# File path
file_path = "customers-100.csv"
df = load_and_clean_data(file_path)
if df is None:
    st.stop()

# Sidebar for navigation
st.sidebar.title("Navigation")
view = st.sidebar.radio("Select View", ["Overview", "Table", "Stats"])

# Clear cache button
if st.sidebar.button("Clear Cache"):
    st.cache_data.clear()
    st.write("Cache cleared. Please refresh the page.")

# Overview View
if view == "Overview":
    st.title("Customer Data Overview")
    st.write("Summary statistics of the cleaned customer dataset.")
    total_customers = len(df)
    unique_countries = df['Country'].nunique()
    most_common_country = df['Country'].mode()[0]
    top_3_cities = df['City'].value_counts().head(3).index.tolist()
    top_5_companies = df['Company'].value_counts().head(5).index.tolist()
    col1, col2 = st.columns(2)
    with col1:
        st.metric("Total Customers", total_customers)
        st.metric("Unique Countries", unique_countries)
    with col2:
        st.metric("Most Common Country", most_common_country)
        st.write("Top 3 Cities:", ", ".join(top_3_cities))
        st.write("Top 5 Companies:", ", ".join(top_5_companies))

# Table View
elif view == "Table":
    st.title("Editable Customer Table")
    st.write("Edit the dataset below and download the updated version.")
    edited_df = st.data_editor(df, num_rows="dynamic")
    if st.button("Export Edited Data"):
        edited_df.to_csv("edited_customers.csv", index=False)
        st.download_button(
            label="Download Edited CSV",
            data=Path("edited_customers.csv").read_bytes(),
            file_name="edited_customers.csv",
            mime="text/csv"
        )

# Stats View
elif view == "Stats":
    st.title("Customer Data Visualizations")
    st.write("Graphical insights into customer distribution.")

    try:
        # Bar chart: Top 5 countries
        st.write("Rendering: Top 5 Countries Bar Chart")
        top_5_countries = df['Country'].value_counts().head(5)
        fig1 = px.bar(x=top_5_countries.index, y=top_5_countries.values,
                      labels={'x': 'Country', 'y': 'Customer Count'}, title="Top 5 Countries by Customer Count")
        st.plotly_chart(fig1)

        # Bar chart: Top 5 cities
        st.write("Rendering: Top 5 Cities Bar Chart")
        top_5_cities = df['City'].value_counts().head(5)
        fig2 = px.bar(x=top_5_cities.index, y=top_5_cities.values,
                      labels={'x': 'City', 'y': 'Customer Count'}, title="Top 5 Cities by Customer Count")
        st.plotly_chart(fig2)

        # Pie chart: Country distribution (Top 5 + Others)
        st.write("Rendering: Country Distribution Pie Chart")
        country_counts = df['Country'].value_counts()
        top_n = 5
        top_countries = country_counts.head(top_n)
        others_count = country_counts.iloc[top_n:].sum()
        pie_data = pd.concat([top_countries, pd.Series([others_count], index=['Others'])])
        fig3 = px.pie(names=pie_data.index, values=pie_data.values,
                      title=f"Customer Distribution by Country (Top {top_n} + Others)")
        st.plotly_chart(fig3)

        # Pie chart: Email domains
        st.write("Rendering: Email Domains Pie Chart")
        df['Email Domain'] = df['Email'].apply(lambda x: x.split('@')[1] if pd.notna(x) else 'Unknown')
        email_domain_counts = df['Email Domain'].value_counts().head(5)
        fig4 = px.pie(names=email_domain_counts.index, values=email_domain_counts.values,
                      title="Customer Distribution by Email Domain")
        st.plotly_chart(fig4)

        # Horizontal bar: Top 10 companies
        st.write("Rendering: Top 10 Companies Horizontal Bar Chart")
        top_10_companies = df['Company'].value_counts().head(10)
        fig5 = px.bar(y=top_10_companies.index, x=top_10_companies.values, orientation='h',
                      labels={'x': 'Customer Count', 'y': 'Company'}, title="Top 10 Companies by Customer Count")
        st.plotly_chart(fig5)

        # Optional: Stacked bar chart (Country + Email Availability)
        st.write("Rendering: Stacked Bar Chart (Country + Email Availability)")
        email_availability = df.copy()
        email_availability['Email Status'] = email_availability['Email'].isna().map({True: 'Missing Email', False: 'Has Email'})
        stacked_data = email_availability.groupby(['Country', 'Email Status']).size().unstack(fill_value=0)
        if stacked_data.empty:
            st.warning("No data available for Stacked Bar Chart. Check 'Email' column.")
        else:
            fig6 = px.bar(stacked_data, barmode='stack',
                          title="Customers by Country and Email Availability",
                          labels={'value': 'Customer Count', 'Country': 'Country'})
            st.plotly_chart(fig6)

        # Optional: Box plot (Company Name Length)
        st.write("Rendering: Box Plot (Company Name Length)")
        df['Company Name Length'] = df['Company'].str.len()
        if df['Company Name Length'].isna().all():
            st.warning("No valid company name lengths for Box Plot. Check 'Company' column.")
        else:
            fig7 = px.box(df, y='Company Name Length',
                          title="Distribution of Company Name Lengths")
            st.plotly_chart(fig7)

    except Exception as e:
        st.error(f"Error rendering visualizations: {e}")

!rm -rf ~/.streamlit/cache

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
from pathlib import Path

# Set page config
st.set_page_config(page_title="Customer Manager & Analyzer", layout="wide")

# Load and clean data
@st.cache_data
def load_and_clean_data(file_path):
    try:
        df = pd.read_csv(file_path)
        df = df.drop_duplicates()
        df = df.dropna(subset=['First Name', 'Email'])
        df = df.drop(columns=['Index', 'Subscription Date'], errors='ignore')
        st.write("Data loaded and cleaned successfully.")
        return df
    except Exception as e:
        st.error(f"Error loading data: {e}")
        return None

# File path
file_path = "customers-100.csv"
df = load_and_clean_data(file_path)
if df is None:
    st.stop()

# Sidebar for navigation
st.sidebar.title("Navigation")
view = st.sidebar.radio("Select View", ["Overview", "Table", "Stats"])

# Clear cache button
if st.sidebar.button("Clear Cache"):
    st.cache_data.clear()
    st.write("Cache cleared. Please refresh the page.")

# Overview View
if view == "Overview":
    st.title("Customer Data Overview")
    st.write("Summary statistics of the cleaned customer dataset.")
    total_customers = len(df)
    unique_countries = df['Country'].nunique()
    most_common_country = df['Country'].mode()[0]
    top_3_cities = df['City'].value_counts().head(3).index.tolist()
    top_5_companies = df['Company'].value_counts().head(5).index.tolist()
    col1, col2 = st.columns(2)
    with col1:
        st.metric("Total Customers", total_customers)
        st.metric("Unique Countries", unique_countries)
    with col2:
        st.metric("Most Common Country", most_common_country)
        st.write("Top 3 Cities:", ", ".join(top_3_cities))
        st.write("Top 5 Companies:", ", ".join(top_5_companies))

# Table View
elif view == "Table":
    st.title("Editable Customer Table")
    st.write("Edit the dataset below and download the updated version.")
    edited_df = st.data_editor(df, num_rows="dynamic")
    if st.button("Export Edited Data"):
        edited_df.to_csv("edited_customers.csv", index=False)
        st.download_button(
            label="Download Edited CSV",
            data=Path("edited_customers.csv").read_bytes(),
            file_name="edited_customers.csv",
            mime="text/csv"
        )

# Stats View
elif view == "Stats":
    st.title("Customer Data Visualizations")
    st.write("Graphical insights into customer distribution.")

    try:
        # Bar chart: Top 5 countries
        st.write("Rendering: Top 5 Countries Bar Chart")
        top_5_countries = df['Country'].value_counts().head(5)
        fig1 = px.bar(x=top_5_countries.index, y=top_5_countries.values,
                      labels={'x': 'Country', 'y': 'Customer Count'}, title="Top 5 Countries by Customer Count")
        st.plotly_chart(fig1)

        # Bar chart: Top 5 cities
        st.write("Rendering: Top 5 Cities Bar Chart")
        top_5_cities = df['City'].value_counts().head(5)
        fig2 = px.bar(x=top_5_cities.index, y=top_5_cities.values,
                      labels={'x': 'City', 'y': 'Customer Count'}, title="Top 5 Cities by Customer Count")
        st.plotly_chart(fig2)

        # Pie chart: Country distribution (Top 5 + Others)
        st.write("Rendering: Country Distribution Pie Chart")
        country_counts = df['Country'].value_counts()
        top_n = 5
        top_countries = country_counts.head(top_n)
        others_count = country_counts.iloc[top_n:].sum()
        pie_data = pd.concat([top_countries, pd.Series([others_count], index=['Others'])])
        fig3 = px.pie(names=pie_data.index, values=pie_data.values,
                      title=f"Customer Distribution by Country (Top {top_n} + Others)")
        st.plotly_chart(fig3)

        # Pie chart: Email domains
        st.write("Rendering: Email Domains Pie Chart")
        df['Email Domain'] = df['Email'].apply(lambda x: x.split('@')[1] if pd.notna(x) else 'Unknown')
        email_domain_counts = df['Email Domain'].value_counts().head(5)
        fig4 = px.pie(names=email_domain_counts.index, values=email_domain_counts.values,
                      title="Customer Distribution by Email Domain")
        st.plotly_chart(fig4)

        # Horizontal bar: Top 10 companies
        st.write("Rendering: Top 10 Companies Horizontal Bar Chart")
        top_10_companies = df['Company'].value_counts().head(10)
        fig5 = px.bar(y=top_10_companies.index, x=top_10_companies.values, orientation='h',
                      labels={'x': 'Customer Count', 'y': 'Company'}, title="Top 10 Companies by Customer Count")
        st.plotly_chart(fig5)

        # Optional: Stacked bar chart (Country + Email Availability)
        st.write("Rendering: Stacked Bar Chart (Country + Email Availability)")
        email_availability = df.copy()
        email_availability['Email Status'] = email_availability['Email'].isna().map({True: 'Missing Email', False: 'Has Email'})
        stacked_data = email_availability.groupby(['Country', 'Email Status']).size().unstack(fill_value=0)
        if stacked_data.empty:
            st.warning("No data available for Stacked Bar Chart. Check 'Email' column.")
        else:
            fig6 = px.bar(stacked_data, barmode='stack',
                          title="Customers by Country and Email Availability",
                          labels={'value': 'Customer Count', 'Country': 'Country'})
            st.plotly_chart(fig6)

        # Optional: Box plot (Company Name Length)
        st.write("Rendering: Box Plot (Company Name Length)")
        df['Company Name Length'] = df['Company'].str.len()
        if df['Company Name Length'].isna().all():
            st.warning("No valid company name lengths for Box Plot. Check 'Company' column.")
        else:
            fig7 = px.box(df, y='Company Name Length',
                          title="Distribution of Company Name Lengths")
            st.plotly_chart(fig7)

    except Exception as e:
        st.error(f"Error rendering visualizations: {e}")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import numpy as np
# import plotly.express as px
# from pathlib import Path
# 
# # Set page config
# st.set_page_config(page_title="Customer Manager & Analyzer", layout="wide")
# 
# # Load and clean data
# @st.cache_data
# def load_and_clean_data(file_path):
#     try:
#         df = pd.read_csv(file_path)
#         df = df.drop_duplicates()
#         df = df.dropna(subset=['First Name', 'Email'])
#         df = df.drop(columns=['Index', 'Subscription Date'], errors='ignore')
#         st.write("Data loaded and cleaned successfully.")
#         return df
#     except Exception as e:
#         st.error(f"Error loading data: {e}")
#         return None
# 
# # File path
# file_path = "customers-100.csv"
# df = load_and_clean_data(file_path)
# if df is None:
#     st.stop()
# 
# # Sidebar for navigation
# st.sidebar.title("Navigation")
# view = st.sidebar.radio("Select View", ["Overview", "Table", "Stats"])
# 
# # Clear cache button
# if st.sidebar.button("Clear Cache"):
#     st.cache_data.clear()
#     st.write("Cache cleared. Please refresh the page.")
# 
# # Overview View
# if view == "Overview":
#     st.title("Customer Data Overview")
#     st.write("Summary statistics of the cleaned customer dataset.")
#     total_customers = len(df)
#     unique_countries = df['Country'].nunique()
#     most_common_country = df['Country'].mode()[0]
#     top_3_cities = df['City'].value_counts().head(3).index.tolist()
#     top_5_companies = df['Company'].value_counts().head(5).index.tolist()
#     col1, col2 = st.columns(2)
#     with col1:
#         st.metric("Total Customers", total_customers)
#         st.metric("Unique Countries", unique_countries)
#     with col2:
#         st.metric("Most Common Country", most_common_country)
#         st.write("Top 3 Cities:", ", ".join(top_3_cities))
#         st.write("Top 5 Companies:", ", ".join(top_5_companies))
# 
# # Table View
# elif view == "Table":
#     st.title("Editable Customer Table")
#     st.write("Edit the dataset below and download the updated version.")
#     edited_df = st.data_editor(df, num_rows="dynamic")
#     if st.button("Export Edited Data"):
#         edited_df.to_csv("edited_customers.csv", index=False)
#         st.download_button(
#             label="Download Edited CSV",
#             data=Path("edited_customers.csv").read_bytes(),
#             file_name="edited_customers.csv",
#             mime="text/csv"
#         )
# 
# # Stats View
# elif view == "Stats":
#     st.title("Customer Data Visualizations")
#     st.write("Graphical insights into customer distribution.")
# 
#     try:
#         # Bar chart: Top 5 countries
#         st.write("Rendering: Top 5 Countries Bar Chart")
#         top_5_countries = df['Country'].value_counts().head(5)
#         fig1 = px.bar(x=top_5_countries.index, y=top_5_countries.values,
#                       labels={'x': 'Country', 'y': 'Customer Count'}, title="Top 5 Countries by Customer Count")
#         st.plotly_chart(fig1)
# 
#         # Bar chart: Top 5 cities
#         st.write("Rendering: Top 5 Cities Bar Chart")
#         top_5_cities = df['City'].value_counts().head(5)
#         fig2 = px.bar(x=top_5_cities.index, y=top_5_cities.values,
#                       labels={'x': 'City', 'y': 'Customer Count'}, title="Top 5 Cities by Customer Count")
#         st.plotly_chart(fig2)
# 
#         # Pie chart: Country distribution (Top 5 + Others)
#         st.write("Rendering: Country Distribution Pie Chart")
#         country_counts = df['Country'].value_counts()
#         top_n = 5
#         top_countries = country_counts.head(top_n)
#         others_count = country_counts.iloc[top_n:].sum()
#         pie_data = pd.concat([top_countries, pd.Series([others_count], index=['Others'])])
#         fig3 = px.pie(names=pie_data.index, values=pie_data.values,
#                       title=f"Customer Distribution by Country (Top {top_n} + Others)")
#         st.plotly_chart(fig3)
# 
#         # Pie chart: Email domains
#         st.write("Rendering: Email Domains Pie Chart")
#         df['Email Domain'] = df['Email'].apply(lambda x: x.split('@')[1] if pd.notna(x) else 'Unknown')
#         email_domain_counts = df['Email Domain'].value_counts().head(5)
#         fig4 = px.pie(names=email_domain_counts.index, values=email_domain_counts.values,
#                       title="Customer Distribution by Email Domain")
#         st.plotly_chart(fig4)
# 
#         # Horizontal bar: Top 10 companies
#         st.write("Rendering: Top 10 Companies Horizontal Bar Chart")
#         top_10_companies = df['Company'].value_counts().head(10)
#         fig5 = px.bar(y=top_10_companies.index, x=top_10_companies.values, orientation='h',
#                       labels={'x': 'Customer Count', 'y': 'Company'}, title="Top 10 Companies by Customer Count")
#         st.plotly_chart(fig5)
# 
#         # Optional: Stacked bar chart (Country + Email Availability)
#         st.write("Rendering: Stacked Bar Chart (Country + Email Availability)")
#         email_availability = df.copy()
#         email_availability['Email Status'] = email_availability['Email'].isna().map({True: 'Missing Email', False: 'Has Email'})
#         stacked_data = email_availability.groupby(['Country', 'Email Status']).size().unstack(fill_value=0)
#         if stacked_data.empty:
#             st.warning("No data available for Stacked Bar Chart. Check 'Email' column.")
#         else:
#             fig6 = px.bar(stacked_data, barmode='stack',
#                           title="Customers by Country and Email Availability",
#                           labels={'value': 'Customer Count', 'Country': 'Country'})
#             st.plotly_chart(fig6)
# 
#         # Optional: Box plot (Company Name Length)
#         st.write("Rendering: Box Plot (Company Name Length)")
#         df['Company Name Length'] = df['Company'].str.len()
#         if df['Company Name Length'].isna().all():
#             st.warning("No valid company name lengths for Box Plot. Check 'Company' column.")
#         else:
#             fig7 = px.box(df, y='Company Name Length',
#                           title="Distribution of Company Name Lengths")
#             st.plotly_chart(fig7)
# 
#     except Exception as e:
#         st.error(f"Error rendering visualizations: {e}")

from pyngrok import ngrok
import subprocess

# Start Streamlit server
process = subprocess.Popen(['streamlit', 'run', 'app.py', '--server.port', '8501'])

# Create a public URL with ngrok
public_url = ngrok.connect(8501)
print(f"Streamlit app is running at: {public_url}")

!pkill ngrok

!pkill streamlit

!ps aux | grep ngrok
!ps aux | grep streamlit

!rm -rf ~/.streamlit/cache

from pyngrok import ngrok
import subprocess
import time

# Terminate existing ngrok tunnels
!pkill ngrok
!pkill streamlit

# Start Streamlit server
process = subprocess.Popen(['streamlit', 'run', 'app.py', '--server.port', '8501'])

# Wait briefly to ensure Streamlit starts
time.sleep(5)

# Create a public URL with ngrok
try:
    public_url = ngrok.connect(8501)
    print(f"Streamlit app is running at: {public_url}")
except Exception as e:
    print(f"Error creating ngrok tunnel: {e}")